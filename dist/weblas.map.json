{"version":3,"sources":["../../../../../usr/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/sgemmcalculator.js","lib/sscalcalculator.js","lib/sclmpcalculator.js","lib/sdwnscalculator.js","lib/test.js","lib/saxpycalculator.js","lib/webgl.js","node_modules/floader/lib/xhr-loader.js","node_modules/async/lib/async.js","../../../../../usr/lib/node_modules/browserify/node_modules/process/browser.js"],"names":["sgemm","M","N","K","alpha","A","B","beta","C","texels1","texels0","rem","WebGL","COMPONENTS_PER_TEXEL","pad","transpose","texture0","gl","createDataTexture","texture1","texture3","createOutputTexture","sgemmcalculator","calculate","rawBuffer","readData","context","deleteTexture","Float32Array","saxpy","a","X","Y","mod","isFloat32Array","fill","saxpycalculator","obj","Object","prototype","toString","call","sscal","b","sscalcalculator","sstd","mu","sigma","sdwns","channels","factor","stride","c","Math","floor","N_out","M_out","sdwnscalculator","sclmp","Number","MIN_VALUE","MAX_VALUE","sclmpcalculator","isNumeric","parseFloat","fromArray","array","type","tranpose","data","shape","length","ii","jj","r","typedArray","result","constructor","i","j","require","SGEMMCalculator","SAXPYCalculator","SSCALCalculator","SDWNSCalculator","SCLMPCalculator","test","module","exports","util","String","format","args","arguments","this","replace","match","number","webgl","standalone","program","createProgram","STANDALONE_FRAGMENT_SHADER","PIPELINE_FRAGMENT_SHADER","TEXTURE_UNIFORM_NAME_0","TEXTURE_UNIFORM_NAME_1","SHARED_LENGTH_UNIFORM_NAME","ALPHA_UNIFORM_NAME","DOT_FUNCTION","ENCODE_FLOAT_FUNCTION","out","selectProgram","bindInputTexture","TEXTURE0","TEXTURE1","bindUniforms","bindOutputTexture","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindInputTexture","texture","textureUnit","name","activeTexture","bindTexture","TEXTURE_2D","sampler","getUniformLocation","uniform1i","K_gl","alpha_gl","uniform1f","LENGTH_UNIFORM_NAME","ADD_UNIFORM_NAME","MUL_UNIFORM_NAME","SELECT_CHANNEL_FUNCTION","N_gl","b_gl","a_gl","pad_gl","LOWER_UNIFORM_NAME","UPPER_UNIFORM_NAME","DownsampleCalculator","INPUT_ROW_COUNT_UNIFORM_NAME","INPUT_COLUMN_COUNT_UNIFORM_NAME","OUTPUT_ROW_COUNT_UNIFORM_NAME","OUTPUT_COLUMN_COUNT_UNIFORM_NAME","FACTOR_UNIFORM_NAME","STRIDE_UNIFORM_NAME","CHANNEL_COUNT_UNIFORM_NAME","M_gl","M_out_gl","N_out_gl","factor_gl","stride_gl","channel_count_gl","async","loader","allclose","RTOL","ATOL","console","log","index","abs","randomArray","row","random","sqrt","push","load","testDirectory","matrixFiles","callback","testFiles","map","item","err","results","matrices","JSON","parse","assert","t","msg","ok","actual","expected","_assert","message","operator","extra","COEFFICIENT_UNIFORM_NAME","options","glOptions","ext","canvas","document","createElement","premultipliedAlpha","preserveDrawingBuffer","getContext","Error","getExtension","e","hasFloat","highp","getShaderPrecisionFormat","FRAGMENT_SHADER","HIGH_FLOAT","hasHighPrecision","precision","vertexShader","createShader","VERTEX_SHADER","shaderSource","PASS_THROUGH_VERTEX_SHADER","compileShader","POSITION_UNIFORM_NAME","TEXTURE_UNIFORM_NAME","fragmentShaderSource","fragmentShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","useProgram","bindVertices","renderer","position","getAttribLocation","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","STATIC_DRAW","vertexAttribPointer","FLOAT","enableVertexAttribArray","texCoords","textureCoords","indices","ELEMENT_ARRAY_BUFFER","vertexIndices","Uint16Array","h","w","texels","PAD_VALUE","createTexture","texImage2D","RGBA","remainder","full_texel_row_len","full_row_texture_width","row_start","last_texel","full_texel_row_end","buffer","BYTES_PER_ELEMENT","texSubImage2D","set","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","destTexture","UNSIGNED_BYTE","height","width","viewport","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","rawbuffer","ArrayBuffer","prod","Uint8Array","readPixels","url","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","errno","open","send","noop","identity","v","toBool","notId","only_once","fn","apply","_once","_isArrayLike","arr","_isArray","_arrayEach","iterator","_map","Array","_range","count","_reduce","memo","x","_forEachOf","object","_keys","key","_indexOf","_keyIterator","coll","len","keys","_restParam","func","startIndex","max","rest","_withoutIndex","value","_eachOfLimit","limit","nextKey","done","running","errored","replenish","doParallel","eachOf","doParallelLimit","doSeries","eachOfSeries","_asyncMap","eachfn","_filter","sort","_reject","cb","_createTester","check","getResult","iteratee","_","_findGetResult","_parallel","tasks","task","_concat","y","concat","_queue","worker","concurrency","payload","_insert","q","pos","started","idle","setImmediate","drain","unshift","saturated","process","_next","workers","removed","workersList","splice","empty","paused","kill","pause","resume","resumeCount","min","_console_fn","error","_times","mapper","_applyEach","fns","go","that","pop","ensureAsync","innerArgs","sync","previous_async","root","self","global","noConflict","_toString","isArray","_isObject","k","hasOwnProperty","_setImmediate","_delay","setTimeout","nextTick","forEach","each","forEachSeries","eachSeries","forEachLimit","eachLimit","forEachOf","completed","iter","forEachOfSeries","iterate","forEachOfLimit","eachOfLimit","mapSeries","mapLimit","inject","foldl","reduce","foldr","reduceRight","reversed","reverse","transform","select","filter","selectLimit","filterLimit","selectSeries","filterSeries","reject","rejectLimit","rejectSeries","any","some","someLimit","all","every","everyLimit","detect","detectSeries","detectLimit","sortBy","comparator","left","right","criteria","auto","addListener","listeners","removeListener","idx","taskComplete","remainingTasks","slice","runningTasks","ready","requires","listener","taskCallback","dep","safeResults","val","rkey","retry","times","parseTimes","acc","parseInt","DEFAULT_TIMES","interval","DEFAULT_INTERVAL","wrappedTask","wrappedCallback","wrappedResults","retryAttempt","finalAttempt","seriesCallback","retryInterval","opts","attempts","series","waterfall","wrapIterator","next","parallel","parallelLimit","makeCallback","callArgs","concatSeries","whilst","doWhilst","calls","until","doUntil","during","truth","doDuring","queue","items","priorityQueue","_compareTasks","priority","_binarySearch","sequence","compare","beg","end","mid","cargo","dir","memoize","hasher","queues","memoized","l","unmemoized","unmemoize","timesSeries","timesLimit","seq","newargs","nextargs","compose","applyEach","applyEachSeries","forever","constant","values","wrapSync","asyncify","then","define","amd","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","title","browser","env","argv","version","versions","on","once","off","removeAllListeners","emit","binding","cwd","chdir","umask"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var WebGL = require(\"./lib/webgl\"),\n\tSGEMMCalculator = require(\"./lib/sgemmcalculator\"),\n\tSAXPYCalculator = require(\"./lib/saxpycalculator\"),\n\tSSCALCalculator = require(\"./lib/sscalcalculator\"),\n\tSDWNSCalculator = require(\"./lib/sdwnscalculator\"),\n\tSCLMPCalculator = require(\"./lib/sclmpcalculator\"),\n\ttest = require(\"./lib/test\");\n\n\nvar gl = new WebGL(),\n\tsgemmcalculator = new SGEMMCalculator(gl),\n\tsaxpycalculator = new SAXPYCalculator(gl),\n\tsscalcalculator = new SSCALCalculator(gl),\n\tsdwnscalculator = new SDWNSCalculator(gl),\n\tsclmpcalculator = new SCLMPCalculator(gl);\n\n\nmodule.exports = {\n\t// level one\n\t\"saxpy\" : saxpy,\n\t\"sscal\" : sscal,   // single precision matrix scale\n\t// level two\n\t// level three\n\t\"sgemm\" : sgemm,   // single precision generalized matrix multiply\n\t// extra\n\t\"sstd\" : sstd,     // single precision Standard Score normalization\n\t\"sdwns\": sdwns,\n\t\"sclmp\": sclmp,\n\t\"gl\" : gl,\n\t\"util\" : { \"fromArray\" : fromArray, \"transpose\" : transpose},\n\t\"test\" : test\n};\n\n/*\n\tTODO: Pipeline\n\n\tload textures\n\tpass to sgemmcalculator shader\n\trun floatdecode shader\n\treturn extracted result\n */\n\n\n/* Wrap the GL calculation object in a (relatively) user friendly function that\n\taccepts TypedArrays\n\n\t* convert the data to (padded) textures in GPU memory\n\t* execute calculation\n\t* read result into an array, and return\n */\nfunction sgemm(M, N, K, alpha, A, B, beta, C){\n\n\t// pack each matrix into a single RGBA texel array, with the second transposed\n\tvar texels0 = A,\n\t\ttexels1;\n\n\tvar rem = (K % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = rem == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - rem;\n\n\ttexels1 = transpose(K, N, B);\n\n\t// create input textures from data\n\tvar texture0 = gl.createDataTexture(M, K, texels0);\n\tvar texture1 = gl.createDataTexture(N, K, texels1);\n\n\tvar texture3 = gl.createOutputTexture(M, N);\n\n\tsgemmcalculator.calculate(M, N, K + pad, alpha, texture0, texture1, null, null, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(M, N);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture1);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n\n}\n\nfunction saxpy(N, a, X, Y){\n\n\tvar rawBuffer;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tvar texels0 = X,\n\t\ttexels1;\n\n\t// TODO: special shader for constant Y\n\tif(isFloat32Array(Y)){\n\t\ttexels1 = Y;\n\t} else {\n\t\ttexels1 = new Float32Array(N);\n\t\ttexels1.fill(Y);\n\t}\n\n\t// create input textures from data\n\tvar texture0 = gl.createDataTexture(1, N, texels0);\n\tvar texture1 = gl.createDataTexture(1, N, texels1);\n\n\tvar texture3 = gl.createOutputTexture(1, N + pad);\n\n\tsaxpycalculator.calculate(N + pad, a, texture0, texture1, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(1, N);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture1);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n\n}\n\nfunction isFloat32Array(obj){\n\treturn Object.prototype.toString.call(obj) === \"[object Float32Array]\";\n}\n/* a more general version of the BLAS Level 1 scale, that works on matrices\n   and includes an elementwise scalar addition\n\n   a * X + b\n   a - scalar\n   X - matrix (M x N)\n   b - scalar\n\n   to get the standard BLAS scal set M = 1 and b = 0\n\n   this function is generally only cost effective to use in a pipeline\n*/\nfunction sscal(M, N, a, X, b){\n\n\tvar rawBuffer;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tvar texels0 = X;\n\tvar texture0 = gl.createDataTexture(M, N, texels0);\n\n\tvar texture3 = gl.createOutputTexture(M, N + pad);\n\n\tsscalcalculator.calculate(M, N, a, texture0, b, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(M, N);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n}\n\n/* Calculate the Standard Score normalization (subtract mean\n   ,divide by standard deviation).\n */\nfunction sstd(M, N, mu, sigma, X){\n\n\tvar rawBuffer;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tvar texels0 = X;\n\tvar texture0 = gl.createDataTexture(M, N, texels0);\n\n\tvar texture3 = gl.createOutputTexture(M, N + pad);\n\n\t// adjust the parameters (for inverse) and call the standard score normalization\n\tsscalcalculator.calculate(M, N + pad, 1.0/sigma, texture0, -1.0 * mu/sigma, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(M, N);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n}\n\n/* downsample an image (taking the max) for Pooling\n\n\tM - rows in input\n\tN - columns in input\n\tc - channels in input\n\tfactor - the downsample factor (width of patch to sample)\n\tstride - width between pooling regions\n\tX - input image\n */\nfunction sdwns(M, N, channels, factor, stride, X){\n\n\n\t// size of the fake third dimension, after packing into our texture\n\tvar c = Math.floor(channels / WebGL.COMPONENTS_PER_TEXEL);\n\t//console.assert(((C * WebGL.COMPONENTS_PER_TEXEL) === channels), 'channel count must be a multiple of four');\n\n\tvar texels0 = X;\n\n\tvar texture0 = gl.createDataTexture(M, N * channels, X);\n\n\tvar N_out = Math.floor((N - factor) / stride) + 1;\n\tvar M_out = Math.floor((M - factor) / stride) + 1;\n\n\tvar texture3 = gl.createOutputTexture(M_out, N_out * channels);\n\n\tsdwnscalculator.calculate(M, N, c, factor, stride, texture0, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(M_out, N_out * channels);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n}\n/*  Elementwise clamp function for matrices on the interval [a, b]. Can also be\n\tused for min or max, by passing Number.MIN_VALUE for the first parameter and\n\tNumber.MAX_VALUE for the second parameter, respectively.\n\n\tPassing `null` for either of these parameters will default to it's\n\trespective min or max value.\n\n\tM - number of rows in X\n\tN - number of columns in X\n\ta - lower bound (inclusize)\n\tb - upper bound (inclusive)\n\tX - matrix\n\n   to get the standard BLAS scal set M = 1 and b = 0\n\n   this function is generally only cost effective to use in a pipeline\n*/\nfunction sclmp(M, N, a, b, X){\n\n\ta = (a != null) ? a : Number.MIN_VALUE;\n\tb = (b != null) ? b : Number.MAX_VALUE;\n\n\tvar rawBuffer;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tvar texels0 = X;\n\tvar texture0 = gl.createDataTexture(M, N, texels0);\n\n\tvar texture3 = gl.createOutputTexture(M, N + pad);\n\n\tsclmpcalculator.calculate(M, N, a, b, texture0, texture3);\n\n\t// retrieve data\n\trawBuffer = gl.readData(M, N);\n\n\t// clean up\n\tgl.context.deleteTexture(texture0);\n\tgl.context.deleteTexture(texture3);\n\n\t// return result\n\treturn new Float32Array(rawBuffer);\n}\n/*\nfunction saxpy(n, a, x, y){\n\tvar i = 0,\n\t\tresult = new Float32Array(n);\n\n\t// assert n = x.length\n\t// assert a is scalar\n\t// assert x is Float32Array\n\n\tif(isNumeric(y)){\n\t\t// shortcut for scalar y\n\t\tfor(; i < n; i++){\n\t\t\tresult[i] = a * x[i] + y;\n\t\t}\n\t} else {\n\n\t\tfor(; i < n; i++){\n\t\t\tresult[i] = a * x[i] + y[i];\n\t\t}\n\t}\n\n\treturn result;\n\n}*/\n\n// add a String.format method, if none exists\nif (!String.prototype.format) {\n  String.prototype.format = function() {\n\tvar args = arguments;\n\treturn this.replace(/{(\\d+)}/g, function(match, number) {\n\t  return typeof args[number] != 'undefined'\n\t\t? args[number]\n\t\t: match\n\t  ;\n\t});\n  };\n}\n\nfunction isNumeric( obj ) { return (obj - parseFloat( obj ) + 1) >= 0; }\n\n/* create a typed array from a 2D javascript array */\nfunction fromArray(array, type, tranpose) {\n\tvar shape = [],\n\t\t\tdata,\n\t\t\tc;   // number of columns\n\n\tif(!tranpose){\n\t\tshape[0] = array.length;\n\t\tshape[1] = array[0].length;\n\t} else {\n\t\tshape[1] = array.length;\n\t\tshape[0] = array[0].length;\n\t}\n\tc = shape[1];\n\n\ttype = type || Float32Array;\n\n\tdata = new type(shape[0]*shape[1]);\n\n\tfor (var ii = 0; ii < shape[0]; ++ii)\n\t\tfor (var jj = 0; jj < shape[1]; ++jj)\n\t\tif(!tranpose)\n\t\t\tdata[ii*c + jj] = array[ii][jj];\n\t\telse\n\t\t\tdata[ii*c + jj] = array[jj][ii];\n\n\treturn data;\n};\n\n// tranpose a typed array in row major order, with the given row and column\n// numers\nfunction transpose(r, c, typedArray){\n\tvar result = new typedArray.constructor(r*c);\n\n\tfor(var i = 0; i < r; i++){\n\t\tfor(var j = 0; j < c; j++){\n\t\t\tresult[j * r + i] = typedArray[i * c + j];\n\t\t}\n\t}\n\n\treturn result;\n}\n","var WebGL = require('./webgl');\n\n/* A calculator object for the Float texture based GEMM\n\n\tGeneralized Matrix Multiply (GEMM):\n\n\tC = alpha * A * B + beta * C\n\n\twhere A * B is matrix multiplication\n\n\n\twebgl - a weblas.WebGL object\n\tstandalone - whether or not to automatically run the floating point encode\n\t\tstep for rendering to an UNSIGNED_BYTE texture (this is required for\n\t\tmobile, circa 2015) but can't be used as part of a pipeline.\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction SGEMMCalculator(webgl, standalone){\n\tthis.webgl = webgl,\n\tthis.standalone = standalone || true; // default to standalone mode\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tif(this.standalone){\n\t\tthis.program = this.webgl.createProgram(SGEMMCalculator.STANDALONE_FRAGMENT_SHADER);\n\t} else {\n\t\tthis.program = this.webgl.createProgram(SGEMMCalculator.PIPELINE_FRAGMENT_SHADER);\n\t}\n\n}\n\nmodule.exports = SGEMMCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nSGEMMCalculator.TEXTURE_UNIFORM_NAME_0 = \"A\";\nSGEMMCalculator.TEXTURE_UNIFORM_NAME_1 = \"B_t\";\nSGEMMCalculator.SHARED_LENGTH_UNIFORM_NAME = \"K\";\nSGEMMCalculator.ALPHA_UNIFORM_NAME = \"alpha\";\n\nSGEMMCalculator.DOT_FUNCTION = \"\\n\\\n float delta_t = 1./float(K);// space (on texture) between elements     \\n\\\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// sum of products between elements in row i (from A) x col j (from B)   \\n\\\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// Calculate the dot product between the row (from A) and column (from B)\\n\\\n// identified by the passed indeces (output texture coordinate space).   \\n\\\n// We loop over elements in the row and column and sum the product       \\n\\\n// using the glsl `dot` function to process four elements at a time.     \\n\\\n// This four element optimization requires that the matrix B be          \\n\\\n// transposed before texel packing and that both matrices be padded      \\n\\\n// (with zeros) to a multiple of four (4) in their shared dimension.     \\n\\\nfloat dot_rowcol(float x, float y) {                                     \\n\\\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair              \\n\\\n\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures \\n\\\n\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\tfor (int l=0 ; l<4096 ; ++l) {                                       \\n\\\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column   \\n\\\n\t\t// l is in pixel space, so we divide by four                     \\n\\\n\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t// retrieve next four elements from each texture                 \\n\\\n\t\tvec4 a_ik = texture2D(  A, vec2(z, x));                          \\n\\\n\t\tvec4 b_kj = texture2D(B_t, vec2(z, y));                          \\n\\\n\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t// use `dot` to process four elements at a time                  \\n\\\n\t\tsum += alpha * dot(a_ik, b_kj);                                  \\n\\\n\t\tz += (4.0 * delta_t);      // (z + 0.5)*delta                              \\n\\\n\t}                                                                    \\n\\\n\treturn sum;                                                          \\n\\\n}\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\nSGEMMCalculator.STANDALONE_FRAGMENT_SHADER = \"                                  \\n\\\n// fragment shader that calculates the matrix product and renders each   \\n\\\n// element to the bytes representing a 32-bit IEEE754 floating point in  \\n\\\n// the output RGBA canvas.                                               \\n\\\n// readPixel is used to read the bytes.                                  \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D A;\t\t// texture with data from padded A           \\n\\\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B \\n\\\nuniform int       K;\t\t// number of elements in shared dimension    \\n\\\nuniform float     alpha; \t// coefficient to multiplication             \\n\\\n\t                                                              \t\t\\n\" +\nSGEMMCalculator.DOT_FUNCTION +\nWebGL.ENCODE_FLOAT_FUNCTION +\n\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate. These map directly to input texture space when\\n\\\n\t// the relevant dimensions are the same.                             \\n\\\n \tfloat row_t = outTex.y;                                                \\n\\\n\tfloat col_t = outTex.x;                                                \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// sum row x col for the passed pixel                                \\n\\\n\tfloat sum = dot_rowcol(row_t, col_t);                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\tif (sum == 0.) {                                                     \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\\n\tgl_FragColor = encodeFloat(sum);\t\t\t\t\t\t\t\t\t \\n\\\n}                                                                        \\n\\\n\";\n\n\n/* Calculate the GEMM, with the given data.\n\n\tM - number of rows in A\n\tN - number of columns in B\n\tK - number of elements in shared dimension (including padding)\n\talpha - scalar for A\n\tA - left hand matrix (as padded texture)\n\tB - transpose of right hand matrix (as padded texture)\n\tbeta - scalar for C\n\tC - additive matrix (texture)\n\tout - output (texture)\n\n  How this works:\n\n  1. Activate our shader program\n  2. Bind input textures\n  3. Set shader program parameters\n  4. Bind output texture\n  5. Activate calculation with `drawElements`\n\n TODO: signature should look like this:\n ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC )\n http://www.math.utah.edu/software/lapack/lapack-blas/dgemm.html\n */\nSGEMMCalculator.prototype.calculate = function(M, N, K, alpha, A, B, beta, C, out){\n\n\tvar gl = this.webgl.context;\n\n\t/*\n\tvar h1 = M, w1 = K,\n\t\th2 = K, w2 = N;\n\t*/\n\n\t// set this calculator program as the active program\n\tthis.webgl.selectProgram(this.program);\n\n\t//  bind our input textures containing matrix data\n\tthis.bindInputTexture(A, gl.TEXTURE0, SGEMMCalculator.TEXTURE_UNIFORM_NAME_0);\n\tthis.bindInputTexture(B, gl.TEXTURE1, SGEMMCalculator.TEXTURE_UNIFORM_NAME_1);\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(K, alpha);\n\n\t// bind our destination texture\n\tthis.webgl.bindOutputTexture(M, N, out);\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\tthis.webgl.unbindInputTexture(gl.TEXTURE0);\n\tthis.webgl.unbindInputTexture(gl.TEXTURE1);\n\n\t// result can now be read with gl.readResult, or more operations can be\n\t// performed on destination texture (in pipeline mode)\n};\n\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\th - number of rows in input matrix\n\tw - number of cols in input matrix\n\ttexels - packed data\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nSGEMMCalculator.prototype.bindInputTexture = function(texture, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n};\n\n\n/* Set up inputs for the texture shader\n\n\tK - size of shared dimension for multiplied matrices\n */\nSGEMMCalculator.prototype.bindUniforms = function(K, alpha) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar K_gl\t = gl.getUniformLocation(this.program, SGEMMCalculator.SHARED_LENGTH_UNIFORM_NAME),\n\t\talpha_gl = gl.getUniformLocation(this.program, SGEMMCalculator.ALPHA_UNIFORM_NAME);\n\n\t// bind length of shared dimension\n\tgl.uniform1i(K_gl, K);\n\t// bind alpha\n\tgl.uniform1f(alpha_gl, alpha);\n\n};\n","var WebGL = require('./webgl');\n\n/*  a more general version of the BLAS Level 1 scale that works on matrices\n    and includes an elementwise scalar addition\n\n    a * X + b\n\n\twhere X is a matrix, a and b are scalars and operations are elementwise\n\n    to get the standard BLAS scal set M = 1 and b = 0\n\n\n\twebgl - a weblas.WebGL object\n\tstandalone - whether or not to automatically run the floating point encode\n\t\tstep for rendering to an UNSIGNED_BYTE texture (this is required for\n\t\tmobile, circa 2015) but can't be used as part of a pipeline.\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction SSCALCalculator(webgl, standalone){\n\tthis.webgl = webgl,\n\tthis.standalone = standalone || true; // default to standalone mode\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tif(this.standalone){\n\t\tthis.program = this.webgl.createProgram(SSCALCalculator.STANDALONE_FRAGMENT_SHADER);\n\t} else {\n\t\tthis.program = this.webgl.createProgram(SSCALCalculator.PIPELINE_FRAGMENT_SHADER);\n\t}\n\n}\n\nmodule.exports = SSCALCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nSSCALCalculator.TEXTURE_UNIFORM_NAME_0 = \"X\";\nSSCALCalculator.LENGTH_UNIFORM_NAME = \"N\";\nSSCALCalculator.ADD_UNIFORM_NAME = \"b\";\nSSCALCalculator.MUL_UNIFORM_NAME = \"a\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\nSSCALCalculator.STANDALONE_FRAGMENT_SHADER = \"                           \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D X;\t\t// texture with data from padded A           \\n\\\nuniform int N; \\n\\\nuniform int pad; \\n\\\nuniform float b; \t\t// additive term                        \\n\\\nuniform float a; \t\t// multiplicative term             \\n\\\n\t                                                              \t\t\\n\" +\nWebGL.ENCODE_FLOAT_FUNCTION +\nWebGL.SELECT_CHANNEL_FUNCTION +\n\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\                                                                      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate. These map directly to input texture space when\\n\\\n\t// the relevant dimensions are the same.                             \\n\\\n \tfloat row = outTex.y;                                                \\n\\\n\tfloat col = outTex.x;                                                \\n\\\n\t\\n\\\n\t// return 0.0 if in padded region of output texture \\n\\\n\tif(col * float(N + pad) > float(N) ) {                               \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}      \\n\\\n\t\\n\\\n\t// direct usage of col requires output be padded exactly like input\t \\n\\\n\tvec4 x = texture2D( X, vec2(col, row));                  \\n\\\n\tvec4 sum_v = (a * x) + b;\\n\\\n\tint channel = int(mod(col * float(N + pad), 4.0 )); \\n\\\n\tfloat sum = selectIndex(sum_v, channel); \\n\\\n\t\\n\\\n\tif (sum == 0.) {                                                     \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\\n\tgl_FragColor = encodeFloat(sum);\t\t\t\t\t\t\t\t\t \\n\\\n}                                                                        \\n\\\n\";\n\n/* Elementwise scale and offset a matrix\n\n\tM - number of rows in X\n\tN - number of columns in X\n\ta - scalar coefficient to X\n\tb - scalar offset of X\n\tX - matrix (texture)\n\tout - output (texture)\n\n  How this works:\n\n  1. Activate our shader program\n  2. Bind input textures\n  3. Set shader program parameters\n  4. Bind output texture\n  5. Activate calculation with `drawElements`\n\n */\nSSCALCalculator.prototype.calculate = function(M, N, a, X, b, out){\n\n\tvar gl = this.webgl.context;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tthis.webgl.selectProgram(this.program);\n\n\t// create and bind our input texture using matrix data\n\tthis.bindInputTexture(X, gl.TEXTURE0, SSCALCalculator.TEXTURE_UNIFORM_NAME_0);\n\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(N, pad, a, b);\n\n\t// create our destination texture\n\tthis.webgl.bindOutputTexture(M, N + pad, out);\n\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\tthis.webgl.unbindInputTexture(gl.TEXTURE0);\n\n};\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\ttexture - texture containing the data\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nSSCALCalculator.prototype.bindInputTexture = function(texture, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n};\n\n/* Set up inputs for the texture shader\n\n */\nSSCALCalculator.prototype.bindUniforms = function(N, pad, a, b) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar N_gl = gl.getUniformLocation(this.program, SSCALCalculator.LENGTH_UNIFORM_NAME),\n\t\tb_gl = gl.getUniformLocation(this.program, SSCALCalculator.ADD_UNIFORM_NAME),\n\t\ta_gl = gl.getUniformLocation(this.program, SSCALCalculator.MUL_UNIFORM_NAME),\n\t\tpad_gl = gl.getUniformLocation(this.program, \"pad\");\n\n\t// bind length of shared dimension\n\tgl.uniform1i(N_gl, N);\n\tgl.uniform1i(pad_gl, pad);\n\tgl.uniform1f(a_gl, a);\n\tgl.uniform1f(b_gl, b);\n\n};\n","var WebGL = require('./webgl');\n\n/*  Elementwise clamp function for matrices on the interval [a, b]. Can also be\n\tused for min or max, by passing Number.MIN_VALUE for the first parameter and\n\tNumber.MAX_VALUE for the second parameter, respectively.\n\n\tPassing `null` for either of these parameters will default to it's\n\trespective min or max value.\n\n\tmax(a, min(b, x)) for each x in X\n\n\twhere X is a matrix, a and b are scalars\n\n\n\twebgl - a weblas.WebGL object\n\tstandalone - whether or not to automatically run the floating point encode\n\t\tstep for rendering to an UNSIGNED_BYTE texture (this is required for\n\t\tmobile, circa 2015) but can't be used as part of a pipeline.\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction SCLMPCalculator(webgl, standalone){\n\tthis.webgl = webgl,\n\tthis.standalone = standalone || true; // default to standalone mode\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tif(this.standalone){\n\t\tthis.program = this.webgl.createProgram(SCLMPCalculator.STANDALONE_FRAGMENT_SHADER);\n\t} else {\n\t\tthis.program = this.webgl.createProgram(SCLMPCalculator.PIPELINE_FRAGMENT_SHADER);\n\t}\n\n}\n\nmodule.exports = SCLMPCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nSCLMPCalculator.TEXTURE_UNIFORM_NAME_0 = \"X\";\nSCLMPCalculator.LENGTH_UNIFORM_NAME = \"N\";\nSCLMPCalculator.LOWER_UNIFORM_NAME = \"a\";\nSCLMPCalculator.UPPER_UNIFORM_NAME = \"b\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\nSCLMPCalculator.STANDALONE_FRAGMENT_SHADER = \"                           \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D X;\t\t// texture with data from padded A           \\n\\\nuniform int N; \\n\\\nuniform int pad; \\n\\\nuniform float a; \t\t// lower bound             \\n\\\nuniform float b; \t\t// upper bound                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \\n\" +\nWebGL.ENCODE_FLOAT_FUNCTION +\nWebGL.SELECT_CHANNEL_FUNCTION +\n\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\                                                                      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate. These map directly to input texture space when\\n\\\n\t// the relevant dimensions are the same.                             \\n\\\n\t float row = outTex.y;                                                \\n\\\n\tfloat col = outTex.x;                                                \\n\\\n\t\\n\\\n\t// return 0.0 if in padded region of output texture \\n\\\n\tif(col * float(N + pad) > float(N) ) {                               \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}      \\n\\\n\t\\n\\\n\t// direct usage of col requires output be padded exactly like input\t \\n\\\n\tvec4 x = texture2D( X, vec2(col, row));                  \\n\\\n\tvec4 val = clamp(x, a, b);\\n\\\n\t// select and output channel (standalone version only)\\n\\\n\tint channel = int(mod(col * float(N + pad), 4.0 )); \\n\\\n\tfloat sum = selectIndex(val, channel); \\n\\\n\t\\n\\\n\tif (sum == 0.) {                                                     \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t // output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\\n\tgl_FragColor = encodeFloat(sum);\t\t\t\t\t\t\t\t\t \\n\\\n}                                                                        \\n\\\n\";\n\n/* Elementwise clamp a matrix to the interval [a, b]\n\n\tM - number of rows in X\n\tN - number of columns in X\n\ta - lower bound (inclusize)\n\tb - upper bound (inclusive)\n\tX - matrix (texture)\n\tout - output (texture)\n\n  How this works:\n\n  1. Activate our shader program\n  2. Bind input textures\n  3. Set shader program parameters\n  4. Bind output texture\n  5. Activate calculation with `drawElements`\n\n */\nSCLMPCalculator.prototype.calculate = function(M, N, a, b, X, out){\n\n\ta = (a != null) ? a : Number.MIN_VALUE;\n\tb = (b != null) ? b : Number.MAX_VALUE;\n\n\tvar gl = this.webgl.context;\n\n\tvar mod = (N % WebGL.COMPONENTS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : WebGL.COMPONENTS_PER_TEXEL - mod;\n\n\tthis.webgl.selectProgram(this.program);\n\n\t// create and bind our input texture using matrix data\n\tthis.bindInputTexture(X, gl.TEXTURE0, SCLMPCalculator.TEXTURE_UNIFORM_NAME_0);\n\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(N, pad, a, b);\n\n\t// create our destination texture\n\tthis.webgl.bindOutputTexture(M, N + pad, out);\n\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\tthis.webgl.unbindInputTexture(gl.TEXTURE0);\n\n};\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\th - number of rows in input matrix\n\tw - number of cols in input matrix\n\ttexels - packed data\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nSCLMPCalculator.prototype.bindInputTexture = function(texture, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n};\n\n/* Set up inputs for the texture shader\n\n */\nSCLMPCalculator.prototype.bindUniforms = function(N, pad, a, b) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar N_gl = gl.getUniformLocation(this.program, SCLMPCalculator.LENGTH_UNIFORM_NAME),\n\t\tb_gl = gl.getUniformLocation(this.program, SCLMPCalculator.UPPER_UNIFORM_NAME),\n\t\ta_gl = gl.getUniformLocation(this.program, SCLMPCalculator.LOWER_UNIFORM_NAME),\n\t\tpad_gl = gl.getUniformLocation(this.program, \"pad\");\n\n\t// bind length of shared dimension\n\tgl.uniform1i(N_gl, N);\n\tgl.uniform1i(pad_gl, pad);\n\tgl.uniform1f(a_gl, a);\n\tgl.uniform1f(b_gl, b);\n\n};\n","var WebGL = require('./webgl');\n\n/*  Downsample an image (useful in pooling layers).\n\n\n\n\twebgl - a weblas.WebGL object\n\tstandalone - whether or not to automatically run the floating point encode\n\t\tstep for rendering to an UNSIGNED_BYTE texture (this is required for\n\t\tmobile, circa 2015) but can't be used as part of a pipeline.\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction DownsampleCalculator(webgl, standalone){\n\tthis.webgl = webgl,\n\tthis.standalone = standalone || true; // default to standalone mode\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tif(this.standalone){\n\t\tthis.program = this.webgl.createProgram(DownsampleCalculator.STANDALONE_FRAGMENT_SHADER);\n\t} else {\n\t\tthis.program = this.webgl.createProgram(DownsampleCalculator.PIPELINE_FRAGMENT_SHADER);\n\t}\n\n}\n\nmodule.exports = DownsampleCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nDownsampleCalculator.TEXTURE_UNIFORM_NAME_0 = \"X\";\nDownsampleCalculator.INPUT_ROW_COUNT_UNIFORM_NAME = \"M\";\nDownsampleCalculator.INPUT_COLUMN_COUNT_UNIFORM_NAME = \"N\";\nDownsampleCalculator.OUTPUT_ROW_COUNT_UNIFORM_NAME = \"M_out\";\nDownsampleCalculator.OUTPUT_COLUMN_COUNT_UNIFORM_NAME = \"N_out\";\nDownsampleCalculator.FACTOR_UNIFORM_NAME = \"factor\";\nDownsampleCalculator.STRIDE_UNIFORM_NAME = \"stride\";\nDownsampleCalculator.CHANNEL_COUNT_UNIFORM_NAME = \"c\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\n // TODO: unroll loop for stride == factor and small values (2, 3)\nDownsampleCalculator.STANDALONE_FRAGMENT_SHADER = \"                      \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D X;\t\t// texture with data from padded A           \\n\\\nuniform int factor; // width of image patch\\n\\\nuniform float stride; // width between image patches\\n\\\nuniform float c; \t\t// number of channels \\n\\\nuniform float M;\\n\\\nuniform float N;\\n\\\nuniform float N_out;\\n\\\nuniform float M_out;\\n\\\n\t                                                              \t\t\\n\" +\nWebGL.ENCODE_FLOAT_FUNCTION +\nWebGL.SELECT_CHANNEL_FUNCTION +\n\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\                                                                      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate and translate to input texture space.          \\n\\\n\tfloat row_p = floor(outTex.y * M_out);   // row on output texture (pixel space)   \\n\\\n\tfloat col_p = floor(outTex.x * N_out/4.0); // column on output texture (pixel space)\\n\\\n\tfloat vcol_p = floor(col_p / c);   // virtual column on output texture (pixel space)\\n\\\n\tfloat vchannel_p = mod(col_p, c); // virtual channel on output texture\\n\\\n\t\\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\tconst float min = -1.0e+08;\\n\\\n\tvec4 currentMax = vec4(min, min, min, min); \\n\\\n\t\\n\\\n\tfloat deltaY = 1.0/M;\\n\\\n\tfloat deltaX = 4.0/N;\\n\\\n\tfloat y = ((row_p * stride) + 0.5)*deltaY; // position of input row\t\t\t\t\\n\\\n\tfloat x; \\n\\\n\tfloat z = vchannel_p * deltaX;\\n\\\n\tfor (int i = 0; i < 100; i += 1) {\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tif (i >= factor) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tx = ((vcol_p * stride * c) + 0.5) * deltaX; // position of input column\t\\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tfor (int j = 0; j < 100; j += 1) {\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\tif (j >= factor) {\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\tvec2 coords = vec2(x + z, y); \\n\\\n\t        vec4 x_v = texture2D(X, coords);\t\t\t\t\\n\\\n\t        currentMax = max(currentMax, x_v);\t\t\t\t\t\t\t\t\\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t\tx += (deltaX * c);\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\ty += deltaY;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\tint chan = int(mod(outTex.x * N_out, 4.0 )); \\n\\\n\tfloat val = selectIndex(currentMax, int(chan)); \\n\\\n\tif (val == 0.) {                                                 \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                   \\n\\\n\t\\n\\\n\tgl_FragColor = encodeFloat(val);\\n\\\n}\";\n\n\n/* Downsample (pool) the input using the maximum for each channel.\n\n\tM - rows in X\n\tN - columns in X\n\tc - (channels / 4) in X\n\tfactor - the number of pixels (width and height) to combine\n\tstride - amount between groups of pixels\n\tX - input matrix (texture)\n\tout - output (texture)\n\n  How this works:\n\n  1. Activate our shader program\n  2. Bind input textures\n  3. Set shader program parameters\n  4. Bind output texture\n  5. Activate calculation with `drawElements`\n\n */\nDownsampleCalculator.prototype.calculate = function(M, N, c, factor, stride, X, out){\n\n\tvar gl = this.webgl.context;\n\n\n    var N_out = (Math.floor((N - factor) / stride) + 1) * c * WebGL.COMPONENTS_PER_TEXEL;\n    var M_out = Math.floor((M - factor) / stride) + 1;\n\n\tthis.webgl.selectProgram(this.program);\n\n\t// create and bind our input texture using matrix data\n\tthis.bindInputTexture(X, gl.TEXTURE0, DownsampleCalculator.TEXTURE_UNIFORM_NAME_0);\n\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(M, N * c * WebGL.COMPONENTS_PER_TEXEL, M_out, N_out, factor, stride, c);\n\n\t// create our destination texture\n\tthis.webgl.bindOutputTexture(M_out, N_out, out);\n\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\tthis.webgl.unbindInputTexture(gl.TEXTURE0);\n\n};\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\ttexture - texture containing input values to bind\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nDownsampleCalculator.prototype.bindInputTexture = function(texture, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n};\n\n/* Set up inputs for the texture shader\n\n */\nDownsampleCalculator.prototype.bindUniforms = function(M, N, M_out, N_out, factor, stride, c) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar M_gl = gl.getUniformLocation(this.program, DownsampleCalculator.INPUT_ROW_COUNT_UNIFORM_NAME),\n\t\tN_gl = gl.getUniformLocation(this.program, DownsampleCalculator.INPUT_COLUMN_COUNT_UNIFORM_NAME),\n\t\tM_out_gl = gl.getUniformLocation(this.program, DownsampleCalculator.OUTPUT_ROW_COUNT_UNIFORM_NAME),\n\t\tN_out_gl = gl.getUniformLocation(this.program, DownsampleCalculator.OUTPUT_COLUMN_COUNT_UNIFORM_NAME),\n\t\tfactor_gl = gl.getUniformLocation(this.program, DownsampleCalculator.FACTOR_UNIFORM_NAME),\n\t\tstride_gl = gl.getUniformLocation(this.program, DownsampleCalculator.STRIDE_UNIFORM_NAME),\n\t\tchannel_count_gl = gl.getUniformLocation(this.program, DownsampleCalculator.CHANNEL_COUNT_UNIFORM_NAME);\n\n\t// bind length of shared dimension\n\tgl.uniform1f(M_gl, M);\n\tgl.uniform1f(N_gl, N);\n\tgl.uniform1f(M_out_gl, M_out);\n\tgl.uniform1f(N_out_gl, N_out);\n\tgl.uniform1i(factor_gl, factor);\n\tgl.uniform1f(stride_gl, stride);\n\tgl.uniform1f(channel_count_gl, c);\n\n};\n","var async = require('async'),\n\tloader = require('floader'); // browserify aware file loader (xhr in browser)\n\n/* Collection of helper methods for testing numerical computation\n */\ntest = {};\n\n/* Check all entries in two TypedArrays of identical length for approximate\n\tequality.\n\tIf the following equation is element-wise true, returns true\n\n\tabsolute(a - b) <= (atol + rtol * absolute(b))\n\n\tfrom numpy.allclose\n */\ntest.allclose = function(a, b, RTOL, ATOL){\n\tRTOL= RTOL || 1e-05;  // for 32 bit precision: 1e-06\n\tATOL= ATOL || 1e-08;\n\n\tif(a.length != b.length){\n\t\tconsole.log(\"lengths not equal: \" + a.length + \", \" + b.length);\n\t\treturn {\"result\" : false, \"index\": null};\n\t}\n\n\tvar result;\n\tfor(var i = 0; i < a.length; i++){\n\n\t\tresult = Math.abs(a[i] - b[i]) <= ATOL + RTOL * Math.abs(b[i]);\n\n\t\tif(!result) {\n\t\t\treturn {\"result\": false, \"index\": i};\n\t\t}\n\t}\n\n\treturn {\"result\": true, \"index\": i};\n};\n\ntest.randomArray = function(N, M){\n\n\tvar data = [];\n\n\tfor(var i = 0; i < N; i++){\n\t\tvar row = [];\n\t\tfor(var j = 0; j < M; j++){\n\t\t\trow[j] = Math.random() / Math.sqrt(N);\n\t\t}\n\t\tdata.push(row);\n\t}\n\n\treturn data;\n};\n\n\n/* Load test matrices from JSON data, works in a browser (with XHR)\n\tassumes three files 'a.json', 'b.json' and 'c.json' in nested Array format.\n\n callback = function(err, a, b, c)\n */\ntest.load = function(testDirectory, matrixFiles, callback){\n\n\t// array of paths to matrix data files for current test\n\tvar testFiles = matrixFiles.map(function(item){ return testDirectory + item;});\n\n\t//console.log(testFiles);\n\tasync.map(testFiles, loader.load,\n\t\tfunction(err, results){\n\n\t\t\tif(err) return callback(err);\n\n\t\t\t// results contains three strings.\n\t\t\t// each string contains the contents of a file\n\t\t\t// files contain JSON describing a matrix (2D array)\n\t\t\tvar matrices = results.map(JSON.parse);\n\n\t\t\tcallback(err, matrices);\n\t\t}\n\t);\n};\n\ntest.assert = {};\n\n/* create a tape compatible assert */\ntest.assert.allclose = function(t, a, b, msg, RTOL, ATOL) {\n\n\tvar ok = test.allclose(a, b, RTOL, ATOL),\n\t\tactual = \"[..., \",\n\t\texpected = \"[..., \";\n\n\tif(!ok.result){\n\t\tfor(var i = ok.index; i < ok.index + 4 && i < a.length; i++ ){\n\t\t\tactual += a[i] + \", \";\n\t\t\texpected += b[i] + \", \";\n\t\t}\n\t\tactual += \"...]\";\n\t\texpected += \"...]\";\n\t\tmsg = msg || 'should be allclose at ' + ok.index;\n\t}\n\n    t._assert(ok.result, {\n        message : msg || 'should be allclose',\n        operator : 'allclose',\n        actual : actual,\n        expected : expected,\n        extra : null\n    });\n}\n\nmodule.exports = test;\n","var WebGL = require('./webgl');\n\n/* A calculator object for the Float texture based AXPY\n\n\ta times X plus Y (AXPY):\n\n\tY = a * X + Y\n\n\twhere X + Y is elementwise matrix addition\n\n\n\twebgl - a weblas.WebGL object\n\tstandalone - whether or not to automatically run the floating point encode\n\t\tstep for rendering to an UNSIGNED_BYTE texture (this is required for\n\t\tmobile, circa 2015) but can't be used as part of a pipeline.\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction SAXPYCalculator(webgl, standalone){\n\tthis.webgl = webgl,\n\tthis.standalone = standalone || true; // default to standalone mode\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tif(this.standalone){\n\t\tthis.program = this.webgl.createProgram(SAXPYCalculator.STANDALONE_FRAGMENT_SHADER);\n\t} else {\n\t\tthis.program = this.webgl.createProgram(SAXPYCalculator.PIPELINE_FRAGMENT_SHADER);\n\t}\n\n}\n\nmodule.exports = SAXPYCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nSAXPYCalculator.TEXTURE_UNIFORM_NAME_0 = \"X\";\nSAXPYCalculator.TEXTURE_UNIFORM_NAME_1 = \"Y\";\nSAXPYCalculator.LENGTH_UNIFORM_NAME = \"N\";\nSAXPYCalculator.COEFFICIENT_UNIFORM_NAME = \"a\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\nSAXPYCalculator.STANDALONE_FRAGMENT_SHADER = \"                           \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D X;\t\t// texture with data from padded A           \\n\\\nuniform sampler2D Y;\t\t// texture with data from padded transpose of B \\n\\\nuniform int N; \\n\\\nuniform float a; \t\t// coefficient to multiplication             \\n\\\n\t                                                              \t\t\\n\" +\nWebGL.ENCODE_FLOAT_FUNCTION +\nWebGL.SELECT_CHANNEL_FUNCTION +\n\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\                                                                      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate. These map directly to input texture space when\\n\\\n\t// the relevant dimensions are the same.                             \\n\\\n \tfloat row = outTex.y;                                                \\n\\\n\tfloat col = outTex.x;                                                \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// direct usage of col requires output be padded exactly like input\t \\n\\\n\tvec4 x = texture2D( X, vec2(col, row));                                  \\n\\\n\tvec4 y = texture2D( Y, vec2(col, row));                                  \\n\\\n\tvec4 sum_v = (a * x) + y;                                    \\n\\\n\tint channel = int(mod(col * float(N), 4.0 )); \\n\\\n\tfloat sum = selectIndex(sum_v, channel); \\n\\\n\t\\n\\\n\tif (sum == 0.) {                                                     \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\\n\tgl_FragColor = encodeFloat(sum);\t\t\t\t\t\t\t\t\t \\n\\\n}                                                                        \\n\\\n\";\n\n/* Calculate the AXPY, with the given data.\n\n\tN - number of elements in X and Y\n\ta - scalar coefficient to X\n\tX - left hand vector (texture)\n\tY - right hand vector (texture)\n\tout - output (texture)\n\n  How this works:\n\n  1. Activate our shader program\n  2. Bind input textures\n  3. Set shader program parameters\n  4. Bind output texture\n  5. Activate calculation with `drawElements`\n\n */\nSAXPYCalculator.prototype.calculate = function(N, a, X, Y, out){\n\n\tvar gl = this.webgl.context;\n\n\t/*\n\tvar h1 = M, w1 = K,\n\t\th2 = K, w2 = N;\n\t*/\n\n\tthis.webgl.selectProgram(this.program);\n\n\t// create and bind our input texture using matrix data\n\tthis.bindInputTexture(X, gl.TEXTURE0, SAXPYCalculator.TEXTURE_UNIFORM_NAME_0);\n\tthis.bindInputTexture(Y, gl.TEXTURE1, SAXPYCalculator.TEXTURE_UNIFORM_NAME_1);\n\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(N, a);\n\n\t// create our destination texture\n\tthis.webgl.bindOutputTexture(1, N, out);\n\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\tthis.webgl.unbindInputTexture(gl.TEXTURE0);\n\tthis.webgl.unbindInputTexture(gl.TEXTURE1);\n\n};\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\th - number of rows in input matrix\n\tw - number of cols in input matrix\n\ttexels - packed data\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nSAXPYCalculator.prototype.bindInputTexture = function(texture, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n};\n\n/* Set up inputs for the texture shader\n\n */\nSAXPYCalculator.prototype.bindUniforms = function(N, a) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar N_gl = gl.getUniformLocation(this.program, SAXPYCalculator.LENGTH_UNIFORM_NAME),\n\t\ta_gl = gl.getUniformLocation(this.program, SAXPYCalculator.COEFFICIENT_UNIFORM_NAME);\n\n\t// bind length of shared dimension\n\tgl.uniform1i(N_gl, N);\n\tgl.uniform1f(a_gl, a);\n\n};\n","/*\nCopyright (c) 2015 Waylon Flinn\n\nwebgl.js\n\nmultiply matrices up to 4096 x 4096 on GPUs that support OES_texture_float\nextension. input is encoded into the red and green channels of an input texture and\ncalculations are done using a custom fragment shader.\n\n*/\n\n\n/*\n\tA WebGL context associated with a specific canvas element.\n\n\t* creates a canvas\n\t* sets up webgl context\n\t* translates numbers into textures\n\t* compiles shader programs for executing math (when supplied with an\n\t\toperation specific fragment shader)\n */\nfunction WebGL(options) {\n\n\tvar glOptions,\n\t\text;\n\n\toptions = options || {};\n\n\t// canvas\n\tif(typeof options.canvas === 'undefined')\n\t\tthis.canvas = document.createElement('canvas');\n\telse\n\t\tthis.canvas = options.canvas;\n\n\t// context\n\tglOptions = { premultipliedAlpha: false, preserveDrawingBuffer: false };\n\tthis.context = this.canvas.getContext(\"experimental-webgl\", glOptions);\n\n\tif (typeof this.context === 'undefined')\n\t\tthrow new Error(\"No support for Webgl.\");\n\n\t// float texture extension\n\ttry {\n\t\text = this.context.getExtension('OES_texture_float');\n\t} catch(e) {\n\n\t}\n\tif ( !ext ) {\n\t\tconsole.log(\"No support for OES_texture_float extension.\");\n\t\tthis.hasFloat = false;\n\t} else {\n\t\tthis.hasFloat = true;\n\t}\n\n\tvar highp = this.context.getShaderPrecisionFormat(this.context.FRAGMENT_SHADER, this.context.HIGH_FLOAT);\n\tthis.hasHighPrecision = highp.precision != 0;\n\tif(this.hasHighPrecision) this.highp = highp;\n\n\t// create pass through vertex shader\n\tthis.vertexShader = this.context.createShader(this.context.VERTEX_SHADER);\n\tthis.context.shaderSource(this.vertexShader, WebGL.PASS_THROUGH_VERTEX_SHADER);\n\tthis.context.compileShader(this.vertexShader);\n\n};\n\nmodule.exports = WebGL;\n\n// RGBA is the standard input/ouput texture\nWebGL.COMPONENTS_PER_TEXEL = 4;\n\nWebGL.POSITION_UNIFORM_NAME = \"pos\";\nWebGL.TEXTURE_UNIFORM_NAME = \"tex\";\n\nWebGL.PASS_THROUGH_VERTEX_SHADER = \"\\\n// vertex shader for a single quad                                           \\n\\\n// work is performed in the operation specific texture shader                \\n\\\n\t\t                                                                     \\n\\\nprecision highp float;                                                       \\n\\\n\t\t                                                                     \\n\\\nattribute vec3 pos;                                                         \\n\\\nattribute vec2 tex;                                                         \\n\\\nvarying vec2   outTex;                                                         \\n\\\nvoid main(void)                                                              \\n\\\n{                                                                            \\n\\\n\t// just pass the position and texture coords                             \\n\\\n\tgl_Position = vec4(pos, 1.0);                                           \\n\\\n\toutTex = tex;                                                             \\n\\\n}                                                                            \\n\\\n\";\n\nWebGL.ENCODE_FLOAT_FUNCTION = \"\\n\\\n// Render float to bytes according to IEEE 754 Floating Point            \\n\\\nvec4 encodeFloat(float val) {                                            \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// TODO: correctly handle denormal numbers                           \\n\\\n// http://www.2ality.com/2012/04/number-encoding.html                \\n\\\nfloat a = abs(val);                           // encode absolute value + sign \\n\\\nfloat exp = floor(log2(a));                 // number of powers of 2 \\n\\\nfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1) \\n\\\nfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa \\n\\\nfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits         \\n\\\nfloat mant3 = mod(mant,256.);               // third 8 bits          \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nhighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0  \\n\\\nhighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign     \\n\\\nhighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit \\n\\\nhighp float m2 = (mant2)/255.;\t\t\t\t// middle part           \\n\\\nhighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nreturn vec4(m3,m2,m1,e);                                             \\n\\\n}\";\n\n/*\n\tuse a loop for this instead?\n\tvectors can be indexed with loop indeces\n\thttp://stackoverflow.com/questions/19529690/index-expression-must-be-constant-webgl-glsl-error\n */\nWebGL.SELECT_CHANNEL_FUNCTION = \"\t\t\t\t\t\t\t\t\t\\n\\\nfloat selectIndex(vec4 v, int index){\t\t\t\t\t\t\t\t\\n\\\n\tfloat val;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\tif (index == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tval = v.r;\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t} else if(index == 1) {\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tval = v.g;\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t} else if(index == 2) {\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tval = v.b;\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t} else if(index == 3){\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tval = v.a;\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\t// should never be here\t\t\t\t\t\t\t\t\t\t\\n\\\n\t\tval = 0.0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n\treturn val;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\n\\\n}\";\n\n/*  Create a shader program based on a pass through vertex shader and\n\tthe supplied operation specific fragment shader.\n\n\tfragmentShaderSource - string containing the fragment shader source code.\n\tshader will recieve `vec2 outTex` with texture coordinates from the pass\n\tthrough vertex shader.\n */\nWebGL.prototype.createProgram = function(fragmentShaderSource){\n\tvar gl = this.context,\n\t\tfragmentShader;\n\n\t// compile the provided fragment/texture shader\n\tfragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\tgl.shaderSource(fragmentShader, fragmentShaderSource);\n\tgl.compileShader(fragmentShader);\n\n\t// did it compile correctly?\n\tif (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) == 0)\n\t\tthrow new Error(gl.getShaderInfoLog(fragmentShader));\n\n\t// link the program specific fragment shader and the generic pass through\n\t// shader into a program\n\tvar program = gl.createProgram();\n\tgl.attachShader(program, this.vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\n\treturn program;\n};\n\nWebGL.prototype.selectProgram = function(program){\n\n\tvar gl = this.context;\n\n\t// set calculator program to current shader program\n\tgl.useProgram(program);\n\n\tthis.bindVertices(program);\n};\n\n/* setup required to draw a square to our vertex shader and have\n   fragment shader called for each pixel\n */\nWebGL.prototype.bindVertices = function(program) {\n\tvar gl = this.context,\n\t\trenderer = program;\n\n\t// bind vertices\n\tvar position = gl.getAttribLocation(renderer, WebGL.POSITION_UNIFORM_NAME);\n\tvar vertexBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n\t// define a square that covers the screen\n\tvar vertices = [-1.0, -1.0, 0.0,\t// bottom left\n\t\t\t\t\t 1.0, -1.0, 0.0,\t// bottom right\n\t\t\t\t\t 1.0,  1.0, 0.0,\t// top right\n\t\t\t\t\t-1.0,  1.0, 0.0];\t// top left\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tgl.vertexAttribPointer(position, /*item size*/3, gl.FLOAT, false, 0, 0);\n\tgl.enableVertexAttribArray(position);\n\n\t// bind texture cords\n\tvar texture = gl.getAttribLocation(renderer, WebGL.TEXTURE_UNIFORM_NAME);\n\tvar texCoords = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, texCoords);\n\tvar textureCoords = [0.0, 0.0,\n\t\t\t\t\t\t 1.0, 0.0,\n\t\t\t\t\t\t 1.0, 1.0,\n\t\t\t\t\t\t 0.0, 1.0];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);\n\tgl.vertexAttribPointer(texture, /*item size*/2, gl.FLOAT, false, 0, 0);\n\tgl.enableVertexAttribArray(texture);\n\n\t// index to vertices\n\tvar indices = gl.createBuffer();\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\t// tesselate square into triangles\n\t// indeces into vertex array creating triangles, with counter-clockwise winding\n\tvar vertexIndices = [0, 1, 2,\t// bottom right triangle\n\t\t\t\t\t\t 0, 2, 3];\t// top left triangle\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);\n};\n\n/* create RGBA texture of width w/4 from given texels\n   padding the width of each row to a multiple of 4, where necessary.\n\n   if texels is null, an empty texture is created.\n\n   alternative to textures?\n   http://stackoverflow.com/questions/17203508/webgl-hardware-skinning-with-a-bone-texture\n */\nWebGL.prototype.createDataTexture = function(h, w, texels){\n\n\tvar gl = this.context;\n\n\tvar COMPONENTS_PER_TEXEL = 4,\n\t\tPAD_VALUE = 0.0; // value to pad remainder with\n\n\tvar rem = (w % COMPONENTS_PER_TEXEL),\n\t\tpad = rem == 0 ? 0 : COMPONENTS_PER_TEXEL - rem;\n\n\t// create the texture from our floats\n\tvar texture = gl.createTexture();\n\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\t/*\n\t// https://www.opengl.org/wiki/GLAPI/glPixelStore\n    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, w/4);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n\tsee also: https://www.opengl.org/wiki/Common_Mistakes#Creating_a_complete_texture\n\t*/\n\tif(pad == 0 || texels == null || typeof texels === 'undefined'){\n\t\t// no padding required, write directly from input array\n\t\tgl.texImage2D(\t  gl.TEXTURE_2D, 0, gl.RGBA, w / COMPONENTS_PER_TEXEL, h, 0,\n\t\t\t\t\t\t  gl.RGBA, gl.FLOAT, texels);\n\n\t} else {\n\t\t// must pad each row\n\n\t\t// create empty texture\n\t\tgl.texImage2D(\t  gl.TEXTURE_2D, 0, gl.RGBA, (w + pad) / COMPONENTS_PER_TEXEL, h, 0,\n\t\t\t\t\t\t  gl.RGBA, gl.FLOAT, null);\n\n\t\tvar full_texel_row_len = w - rem,\n\t\t\tfull_row_texture_width = full_texel_row_len / COMPONENTS_PER_TEXEL;\n\n\t\tvar row_start = 0;\n\t\tvar last_texel = new Float32Array(COMPONENTS_PER_TEXEL);\n\t\tvar row, remainder;\n\n\t\t// set texture data, one row at a time, padding each row to a multiple\n\t\t// of the texel length\n\t\tfor(var i = 0; i < h; i++){\n\t\t\trow_start = i * w;\n\t\t\tfull_texel_row_end = row_start + full_texel_row_len;\n\t\t\trow = new Float32Array(texels.buffer, row_start * texels.BYTES_PER_ELEMENT, full_texel_row_len);\n\t\t\tif(full_texel_row_len > 0){\n\t\t\t\t// https://www.khronos.org/registry/webgl/specs/latest/1.0/index.html#TEXSUBIMAGE2D\n\t\t\t\tgl.texSubImage2D(gl.TEXTURE_2D,\n\t\t\t\t\t 0,\t\t\t\t\t// mip-map level\n\t\t\t\t\t 0,\t\t\t\t\t// x-offset\n\t\t\t\t\t i,\t\t\t\t\t// y-offset\n\t\t\t\t\t full_row_texture_width,\t// width\n\t\t\t\t\t 1,\t\t\t\t\t// height\n\t\t\t\t\t gl.RGBA,\t\t\t// format\n\t\t\t\t\t gl.FLOAT,\t\t\t// type\n\t\t\t\t\t row\t\t\t// data\n\t\t\t\t );\n\t\t\t}\n\n\t\t\t// pad the last pixel to 4 components, using PAD_VALUE for extra\n\t\t\tlast_texel.fill(PAD_VALUE);\n\t\t\tremainder = new Float32Array(texels.buffer, full_texel_row_end * texels.BYTES_PER_ELEMENT, rem);\n\t\t\tlast_texel.set(remainder); // copy remaining data\n\n\t\t\tgl.texSubImage2D(gl.TEXTURE_2D,\n\t\t\t\t 0,\t\t\t\t// mip-map level\n\t\t\t\t full_row_texture_width, // x-offset\n\t\t\t\t i,\t\t\t\t// y-offset\n\t\t\t\t 1,\t\t\t\t// width\n\t\t\t\t 1,\t\t\t\t// height\n\t\t\t\t gl.RGBA,\t\t// format\n\t\t\t\t gl.FLOAT,\t\t// type\n\t\t\t\t last_texel\t\t// data\n\t\t\t );\n\t\t}\n\t}\n\n\t// clamp to edge to support non-power of two textures\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n\t// don't interpolate when getting data from texture\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n\t// we're done with setup, so unbind current texture\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\treturn texture;\n};\n\n/* Create a texture suitable for reading into an array with readPixels.\n\tUNSIGNED_BYTE\n   Can be passed to bindDestinationTexture.\n\n   Returns an unsigned byte RGBA texture (other formats are not yet supported\n\ton most platforms, see WEBGL_color_buffer_float extension)\n */\nWebGL.prototype.createOutputTexture = function(h, w) {\n\tvar gl = this.context;\n\n\t// create and bind texture to render to\n\tvar destTexture = gl.createTexture();\n\t//gl.activeTexture(gl.TEXTURE2);\n\tgl.bindTexture(gl.TEXTURE_2D, destTexture);\n\tgl.texImage2D(gl.TEXTURE_2D,/*level*/0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n\t// clamp to edge to support non-power of two textures\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t// don't interpolate when getting data from texture\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n\t// we're done with setup, so unbind current texture\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\treturn destTexture;\n};\n\n/* Set up output\n\n\tM - number of rows in output\n\tN - number of columns in output\n\tdstTex - texture for holding the output\n */\nWebGL.prototype.bindOutputTexture = function(M, N, texture) {\n\tvar gl = this.context;\n\n\t// set canvas and viewport size\n\tthis.canvas.height = M;\n\tthis.canvas.width = N;\n\tgl.viewport(0, 0, N, M);\n\n\t// create and bind framebuffer\n\tthis.framebuffer = this.framebuffer || gl.createFramebuffer();\n\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, /*level*/0);\n\n\n\tif( gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE)\n\t\tthrow new Error(\"Bound framebuffer is not complete.\");\n\n\treturn this.framebuffer;\n};\n\nWebGL.prototype.unbindInputTexture = function(textureUnit){\n\tvar gl = this.context;\n\n\tgl.activeTexture(textureUnit);\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n};\n\n/* Read data out as unsigned bytes */\nWebGL.prototype.readData = function(M, N){\n\tvar gl = this.context;\n\n\t// create destination buffer\n\trawbuffer = new ArrayBuffer(M*N*Float32Array.BYTES_PER_ELEMENT);\n\n\t// read the result into our buffer, as bytes\n\tprod = new Uint8Array(rawbuffer);\n\tgl.readPixels(0, 0, N, M, gl.RGBA, gl.UNSIGNED_BYTE, prod);\n\n\t// return raw result bytes\n\treturn rawbuffer; // M x N\n}\n","exports.load = function(url, callback) {\n\tvar xhr = new XMLHttpRequest();\n\n\txhr.onreadystatechange = function() {\n\t\tif (xhr.readyState !== 4) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (xhr.status >= 200 && xhr.status < 300) {\n\t\t\tcallback(null, xhr.responseText);\n\t\t} else {\n\t\t\tvar err = new Error(\"failed to request file '\" + url + \"'\");\n\t\t\t// follow Node.js error signature\n\t\t\terr.errno = 34;\n\t\t\tcallback(err);\n\t\t}\n\t};\n\n\ttry {\n\t\txhr.open('GET', url, true);\n\t\txhr.send(null);\n\t} catch (err) {\n\t\tcallback(err);\n\t}\n};","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (!callback) {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has inexistant dependency');\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback(null);\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    while(workers < q.concurrency && q.tasks.length){\n                        var tasks = q.payload ?\n                            q.tasks.splice(0, q.payload) :\n                            q.tasks.splice(0, q.tasks.length);\n\n                        var data = _map(tasks, function (task) {\n                            return task.data;\n                        });\n\n                        if (q.tasks.length === 0) {\n                            q.empty();\n                        }\n                        workers += 1;\n                        workersList.push(tasks[0]);\n                        var cb = only_once(_next(q, tasks));\n                        worker(data, cb);\n                    }\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"]}
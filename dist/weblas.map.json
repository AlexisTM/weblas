{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/webgl.js","lib/gemmfloatcalculator.js","lib/test.js","node_modules/async/lib/async.js","node_modules/floader/lib/xhr-loader.js","node_modules/browserify/node_modules/process/browser.js"],"names":["WebGL","require","GEMMFloatCalculator","test","module","exports","options","glOptions","ext","canvas","this","document","createElement","premultipliedAlpha","preserveDrawingBuffer","context","getContext","Error","getExtension","e","hasFloat","console","log","highp","getShaderPrecisionFormat","FRAGMENT_SHADER","HIGH_FLOAT","hasHighPrecision","precision","vertexShader","createShader","VERTEX_SHADER","shaderSource","PASS_THROUGH_VERTEX_SHADER","compileShader","POSITION_UNIFORM_NAME","TEXTURE_UNIFORM_NAME","prototype","createProgram","fragmentShaderSource","fragmentShader","gl","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","program","attachShader","linkProgram","selectProgram","useProgram","bindVertices","renderer","position","getAttribLocation","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","vertices","bufferData","Float32Array","STATIC_DRAW","vertexAttribPointer","FLOAT","enableVertexAttribArray","texture","texCoords","textureCoords","indices","ELEMENT_ARRAY_BUFFER","vertexIndices","Uint16Array","createDestinationTexture","h","w","destTexture","createTexture","activeTexture","TEXTURE2","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","bindDestinationTexture","M","N","dstTex","height","width","viewport","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_COMPONENT16","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","framebufferRenderbuffer","DEPTH_ATTACHMENT","fromArray","array","type","tranpose","data","c","shape","length","ii","jj","webgl","TEXTURE_UNIFORM_NAME_0","TEXTURE_UNIFORM_NAME_1","SHARED_LENGTH_UNIFORM_NAME","ALPHA_UNIFORM_NAME","calculate","K","alpha","A","B","beta","C","frameBuffer","rawbuffer","texels0","packData","texels1","mod","pad","bindInputTexture","TEXTURE0","TEXTURE1","bindUniforms","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","drawElements","TRIANGLES","UNSIGNED_SHORT","ArrayBuffer","BYTES_PER_ELEMENT","prod","Uint8Array","readPixels","r","transpose","CHANNELS_PER_TEXEL","k","i","j","p","texelcount","texels","textureUnit","name","sampler","getUniformLocation","uniform1i","K_gl","alpha_gl","uniform1f","async","loader","allclose","a","b","RTOL","ATOL","result","index","Math","abs","randomArray","row","random","sqrt","push","matrixFiles","load","testDirectory","callback","testFiles","map","item","err","results","JSON","parse","noop","identity","v","toBool","notId","only_once","fn","apply","arguments","_once","_isArrayLike","arr","_isArray","_arrayEach","iterator","_map","Array","_range","count","_reduce","memo","x","_forEachOf","object","_keys","key","_indexOf","_keyIterator","coll","len","keys","_restParam","func","startIndex","max","rest","call","_withoutIndex","value","_eachOfLimit","limit","obj","nextKey","done","running","errored","replenish","doParallel","eachOf","doParallelLimit","doSeries","eachOfSeries","_asyncMap","eachfn","_filter","sort","_reject","cb","_createTester","check","getResult","iteratee","_","_findGetResult","_parallel","tasks","task","args","_concat","y","concat","_queue","worker","concurrency","payload","_insert","q","pos","started","idle","setImmediate","drain","unshift","saturated","process","_next","workers","removed","workersList","splice","empty","paused","kill","pause","resume","resumeCount","min","_console_fn","error","_times","mapper","_applyEach","fns","go","that","pop","ensureAsync","innerArgs","sync","previous_async","root","self","global","noConflict","_toString","Object","toString","isArray","_isObject","hasOwnProperty","_setImmediate","_delay","setTimeout","nextTick","forEach","each","forEachSeries","eachSeries","forEachLimit","eachLimit","forEachOf","completed","iter","forEachOfSeries","iterate","forEachOfLimit","eachOfLimit","mapSeries","mapLimit","inject","foldl","reduce","foldr","reduceRight","reversed","reverse","transform","select","filter","selectLimit","filterLimit","selectSeries","filterSeries","reject","rejectLimit","rejectSeries","any","some","someLimit","all","every","everyLimit","detect","detectSeries","detectLimit","sortBy","comparator","left","right","criteria","auto","addListener","listeners","removeListener","idx","taskComplete","remainingTasks","slice","runningTasks","ready","requires","listener","taskCallback","dep","safeResults","val","rkey","retry","times","parseTimes","acc","t","parseInt","DEFAULT_TIMES","interval","DEFAULT_INTERVAL","wrappedTask","wrappedCallback","wrappedResults","retryAttempt","finalAttempt","seriesCallback","retryInterval","opts","attempts","series","waterfall","wrapIterator","next","parallel","parallelLimit","makeCallback","callArgs","concatSeries","whilst","doWhilst","calls","until","doUntil","during","truth","doDuring","queue","items","priorityQueue","_compareTasks","priority","_binarySearch","sequence","compare","beg","end","mid","cargo","dir","memoize","hasher","queues","memoized","l","unmemoized","unmemoize","timesSeries","timesLimit","seq","newargs","nextargs","compose","applyEach","applyEachSeries","forever","constant","values","wrapSync","asyncify","then","message","define","amd","url","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","errno","open","send","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","title","browser","env","argv","version","versions","on","once","off","removeAllListeners","emit","binding","cwd","chdir","umask"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var WebGL = require(\"./lib/webgl\"),\n    GEMMFloatCalculator = require(\"./lib/gemmfloatcalculator\"),\n    test = require(\"./lib/test\");\n\n\n\nmodule.exports = {\n    \"WebGL\" : WebGL,\n    \"GEMMFloatCalculator\" : GEMMFloatCalculator,\n    \"test\" : test\n};\n","/*\nCopyright (c) 2015 Waylon Flinn\n\nwebgl.js\n\nmultiply matrices up to 4096 x 4096 on GPUs that support OES_texture_float\nextension. input is encoded into the red and green channels of an input texture and\ncalculations are done using a custom fragment shader.\n\n*/\n\n\n/*\n\tA WebGL context associated with a specific canvas element.\n\n\t* creates a canvas\n\t* sets up webgl context\n\t* translates numbers into textures\n\t* compiles shader programs for executing math (when supplied with an\n\t\toperation specific fragment shader)\n */\nfunction WebGL(options) {\n\n\tvar glOptions,\n\t\text;\n\n\toptions = options || {};\n\n\t// canvas\n\tif(typeof options.canvas === 'undefined')\n\t\tthis.canvas = document.createElement('canvas');\n\telse\n\t\tthis.canvas = options.canvas;\n\n\t// context\n\tglOptions = { premultipliedAlpha: false, preserveDrawingBuffer: false };\n\tthis.context = this.canvas.getContext(\"experimental-webgl\", glOptions);\n\n\tif (typeof this.context === 'undefined')\n\t\tthrow new Error(\"No support for Webgl.\");\n\n\t// float texture extension\n\ttry {\n\t\text = this.context.getExtension('OES_texture_float');\n\t} catch(e) {\n\n\t}\n\tif ( !ext ) {\n\t\tconsole.log(\"No support for OES_texture_float extension.\");\n\t\tthis.hasFloat = false;\n\t} else {\n\t\tthis.hasFloat = true;\n\t}\n\n\tvar highp = this.context.getShaderPrecisionFormat(this.context.FRAGMENT_SHADER, this.context.HIGH_FLOAT);\n\tthis.hasHighPrecision = highp.precision != 0;\n\tif(this.hasHighPrecision) this.highp = highp;\n\n\t// create pass through vertex shader\n\tthis.vertexShader = this.context.createShader(this.context.VERTEX_SHADER);\n\tthis.context.shaderSource(this.vertexShader, WebGL.PASS_THROUGH_VERTEX_SHADER);\n\tthis.context.compileShader(this.vertexShader);\n\n};\n\nmodule.exports = WebGL;\n\nWebGL.POSITION_UNIFORM_NAME = \"pos\";\nWebGL.TEXTURE_UNIFORM_NAME = \"tex\";\n\nWebGL.PASS_THROUGH_VERTEX_SHADER = \"\\\n// vertex shader for a single quad                                           \\n\\\n// work is performed in the operation specific texture shader                \\n\\\n\t\t                                                                     \\n\\\nprecision highp float;                                                       \\n\\\n\t\t                                                                     \\n\\\nattribute vec3 pos;                                                         \\n\\\nattribute vec2 tex;                                                         \\n\\\nvarying vec2   outTex;                                                         \\n\\\nvoid main(void)                                                              \\n\\\n{                                                                            \\n\\\n\t// just pass the position and texture coords                             \\n\\\n\tgl_Position = vec4(pos, 1.0);                                           \\n\\\n\toutTex = tex;                                                             \\n\\\n}                                                                            \\n\\\n\";\n\n/*  Create a shader program based on a pass through vertex shader and\n\tthe supplied operation specific fragment shader.\n\n\tfragmentShaderSource - string containing the fragment shader source code.\n\tshader will recieve `vec2 outTex` with texture coordinates from the pass\n\tthrough vertex shader.\n */\nWebGL.prototype.createProgram = function(fragmentShaderSource){\n\tvar gl = this.context,\n\t\tfragmentShader;\n\n\t// compile the provided fragment/texture shader\n\tfragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\tgl.shaderSource(fragmentShader, fragmentShaderSource);\n\tgl.compileShader(fragmentShader);\n\n\t// did it compile correctly?\n\tif (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) == 0)\n\t\tthrow new Error(gl.getShaderInfoLog(fragmentShader));\n\n\t// link the program specific fragment shader and the generic pass through\n\t// shader into a program\n\tvar program = gl.createProgram();\n\tgl.attachShader(program, this.vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\n\treturn program;\n};\n\nWebGL.prototype.selectProgram = function(program){\n\n\tvar gl = this.context;\n\n\t// set calculator program to current shader program\n\tgl.useProgram(program);\n\n\tthis.bindVertices(program);\n};\n\n/* setup required to draw a square to our vertex shader and have\n   fragment shader called for each pixel\n */\nWebGL.prototype.bindVertices = function(program) {\n\tvar gl = this.context,\n\t\trenderer = program;\n\n\t// bind vertices\n\tvar position = gl.getAttribLocation(renderer, WebGL.POSITION_UNIFORM_NAME);\n\tvar vertexBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\n\t// define a square that covers the screen\n\tvar vertices = [-1.0, -1.0, 0.0,\t// bottom left\n\t\t\t\t\t 1.0, -1.0, 0.0,\t// bottom right\n\t\t\t\t\t 1.0,  1.0, 0.0,\t// top right\n\t\t\t\t\t-1.0,  1.0, 0.0];\t// top left\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tgl.vertexAttribPointer(position, /*item size*/3, gl.FLOAT, false, 0, 0);\n\tgl.enableVertexAttribArray(position);\n\n\t// bind texture cords\n\tvar texture = gl.getAttribLocation(renderer, WebGL.TEXTURE_UNIFORM_NAME);\n\tvar texCoords = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, texCoords);\n\tvar textureCoords = [0.0, 0.0,\n\t\t\t\t\t\t 1.0, 0.0,\n\t\t\t\t\t\t 1.0, 1.0,\n\t\t\t\t\t\t 0.0, 1.0];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);\n\tgl.vertexAttribPointer(texture, /*item size*/2, gl.FLOAT, false, 0, 0);\n\tgl.enableVertexAttribArray(texture);\n\n\t// index to vertices\n\tvar indices = gl.createBuffer();\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\t// tesselate square into triangles\n\t// indeces into vertex array creating triangles, with counter-clockwise winding\n\tvar vertexIndices = [0, 1, 2,\t// bottom right triangle\n\t\t\t\t\t\t 0, 2, 3];\t// top left triangle\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);\n};\n\n/* Create and bind a texture to store the result.\n   Requires canvas height and width be set to size of output matrix.\n */\nWebGL.prototype.createDestinationTexture = function(h, w) {\n\tvar gl = this.context;\n\n\t// create and bind texture to render to\n\tvar destTexture = gl.createTexture();\n\tgl.activeTexture(gl.TEXTURE2);\n\tgl.bindTexture(gl.TEXTURE_2D, destTexture);\n\tgl.texImage2D(gl.TEXTURE_2D,/*level*/0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n\t// clamp to edge to support non-power of two textures\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t// don't interpolate when getting data from texture\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n\treturn destTexture;\n};\n\n/* Set up output\n\n\tM - number of rows in output\n\tN - number of columns in output\n\tdstTex - texture for holding the output\n */\nWebGL.prototype.bindDestinationTexture = function(M, N, dstTex) {\n\tvar gl = this.context;\n\n\t// set canvas and viewport size\n\tthis.canvas.height = M;\n\tthis.canvas.width = N;\n\tgl.viewport(0, 0, N, M);\n\n\t// create and bind renderbuffer\n\tthis.renderbuffer = this.renderbuffer || gl.createRenderbuffer();\n\n\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\tgl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);\n\n\tgl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16, N, M);\n\n\t// create and bind framebuffer\n\tthis.framebuffer = this.framebuffer || gl.createFramebuffer();\n\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,dstTex,/*level*/0);\n\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.renderbuffer);\n\n\treturn this.framebuffer;\n};\n\n/* create a typed array from a 2D javascript array */\nWebGL.fromArray = function(array, type, tranpose) {\n\tvar shape = [],\n\t\t\tdata,\n\t\t\tc;   // number of columns\n\n\tif(!tranpose){\n\t\tshape[0] = array.length;\n\t\tshape[1] = array[0].length;\n\t} else {\n\t\tshape[1] = array.length;\n\t\tshape[0] = array[0].length;\n\t}\n\tc = shape[1];\n\n\ttype = type || Float32Array;\n\n\tdata = new type(shape[0]*shape[1]);\n\n\tfor (var ii = 0; ii < shape[0]; ++ii)\n\t\tfor (var jj = 0; jj < shape[1]; ++jj)\n\t\tif(!tranpose)\n\t\t\tdata[ii*c + jj] = array[ii][jj];\n\t\telse\n\t\t\tdata[ii*c + jj] = array[jj][ii];\n\n\treturn data;\n};\n","\n\n/* A calculator object for the Float texture based GEMM\n\n\tGeneralized Matrix Multiply (GEMM):\n\n\tC = alpha * A * B + beta * C\n\n\twhere A * B is matrix multiplication\n\n\n\twebgl - a weblas.WebGL object\n\n\t* uploads and downloads data\n\t* executes calculation\n */\nfunction GEMMFloatCalculator(webgl){\n\tthis.webgl = webgl;\n\n\n\t// create the webgl shader program for this calculation\n\t// based on the specific fragment shader for this calculation\n\t// and the generic pass through shader\n\tthis.program = this.webgl.createProgram(GEMMFloatCalculator.FRAGMENT_SHADER);\n\n}\n\nmodule.exports = GEMMFloatCalculator;\n\n/* Names of the uniforms (variables) used in the shader program passed in on\n   each calculation.\n */\nGEMMFloatCalculator.TEXTURE_UNIFORM_NAME_0 = \"A\";\nGEMMFloatCalculator.TEXTURE_UNIFORM_NAME_1 = \"B_t\";\nGEMMFloatCalculator.SHARED_LENGTH_UNIFORM_NAME = \"K\";\nGEMMFloatCalculator.ALPHA_UNIFORM_NAME = \"alpha\";\n\n/* The GLSL fragment shader that carries out the calculation.\n\n   the `outTex` variable is named and defined in the pass-through vertex shader\n */\nGEMMFloatCalculator.FRAGMENT_SHADER = \"                                  \\n\\\n// fragment shader that calculates the matrix product and renders each   \\n\\\n// element to the bytes representing a 32-bit IEEE754 floating point in  \\n\\\n// the output RGBA canvas.                                               \\n\\\n// readPixel is used to read the bytes.                                  \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nprecision highp float;                                                   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvarying vec2      outTex;\t// texture coords of row/column to calculate \\n\\\nuniform sampler2D A;\t\t// texture with data from padded A           \\n\\\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B \\n\\\nuniform int       K;\t\t// number of elements in shared dimension    \\n\\\nuniform float alpha; \t\t// coefficient to multiplication             \\n\\\nfloat delta = 1./float(K);\t// space between items in shared dimension   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// sum of products between elements in row i (from A) x col j (from B)   \\n\\\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// Calculate the dot product between the row (from A) and column (from B)\\n\\\n// identified by the passed indeces (output texture coordinate space).   \\n\\\n// We loop over elements in the row and column and sum the product       \\n\\\n// using the glsl `dot` function to process four elements at a time.     \\n\\\n// This four element optimization requires that the matrix B be          \\n\\\n// transposed before texel packing and that both matrices be padded      \\n\\\n// (with zeros) to a multiple of four (4) in their shared dimension.     \\n\\\nfloat dot_rowcol(float i, float j) {                                     \\n\\\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair              \\n\\\n\tfloat k = 0.5 * delta;\t// position for shared dimension on source textures \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\tfor (int l=0 ; l<2048 ; ++l) {                                       \\n\\\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column   \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t\t// retrieve next four elements from each texture                 \\n\\\n\t\tvec4 a_ik = texture2D(  A, vec2(k, i));                          \\n\\\n\t\tvec4 b_kj = texture2D(B_t, vec2(k, j));                          \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t\t// use `dot` to process four elements at a time                  \\n\\\n\t\tsum += alpha * dot(a_ik, b_kj);                                  \\n\\\n\t\tk += (delta * 4.0);      // (k * 4 + 0.5)*delta                  \\n\\\n\t}                                                                    \\n\\\n\treturn sum;                                                          \\n\\\n}                                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n// Render float to bytes according to IEEE 754 Floating Point            \\n\\\nvec4 encodeFloat(float val) {                                            \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// TODO: correctly handle denormal numbers                           \\n\\\n\t// http://www.2ality.com/2012/04/number-encoding.html                \\n\\\n\tfloat a = abs(val);                           // encode absolute value + sign \\n\\\n\tfloat exp = floor(log2(a));                 // number of powers of 2 \\n\\\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1) \\n\\\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa \\n\\\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits         \\n\\\n\tfloat mant3 = mod(mant,256.);               // third 8 bits          \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0  \\n\\\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign     \\n\\\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit \\n\\\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part           \\n\\\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255      \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\treturn vec4(m3,m2,m1,e);                                             \\n\\\n}                                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\nvoid main(void) {                                                        \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// get the implied row and column from .y and .x of passed (output)  \\n\\\n\t// texture coordinate. These map directly to input texture space when\\n\\\n\t// the relevant dimensions are the same.                             \\n\\\n \tfloat row = outTex.y;                                                \\n\\\n\tfloat col = outTex.x;                                                \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\t// sum row x col for the passed pixel                                \\n\\\n\tfloat sum = dot_rowcol(row, col);                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n\tif (sum == 0.) {                                                     \\n\\\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);                                \\n\\\n\t\treturn;                                                          \\n\\\n\t}                                                                    \\n\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\n\\\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\\n\\\n\tgl_FragColor = encodeFloat(sum);\t\t\t\t\t\t\t\t\t \\n\\\n}                                                                        \\n\\\n\";\n\n/* Calculate the GEMM, with the given data.\n\n\tM - number of rows in A\n\tN - number of columns in B\n\tK - number of elements in shared dimension\n\talpha - scalar for A\n\tA - left hand matrix\n\tB - right hand matrix\n\tbeta - scalar for C\n\tC - additive matrix\n\n  How this works:\n\n  1. Activate our shader program\n  2. Create a texture to hold the input data\n  3. Set shader program parameters (based on matrix sizes)\n  4. Create a texture to hold the output\n  5. Activate calculation with `drawElements`\n  6. Read result with `readPixels` and return it\n\n TODO: signature should look like this:\n ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC )\n http://www.math.utah.edu/software/lapack/lapack-blas/dgemm.html\n */\nGEMMFloatCalculator.prototype.calculate = function(M, N, K, alpha, A, B, beta, C){\n\n\tvar gl = this.webgl.context,\n\t\tdestTexture,\n\t\tframeBuffer,\n\t\trawbuffer;\n\n\t/*\n\tvar h1 = M, w1 = K,\n\t\th2 = K, w2 = N;\n\t*/\n\n\n\tthis.webgl.selectProgram(this.program);\n\n\t// pack each matrix into a single RGBA texel array, with the second transposed\n\tvar texels0 = GEMMFloatCalculator.packData(M, K, A, false);\n\t\ttexels1 = GEMMFloatCalculator.packData(K, N, B, true);\n\n\n\tvar mod = (K % 4),\n\t\tpad = mod == 0 ? 0 : 4 - mod;\n\n\t// create and bind our input texture using matrix data\n\tthis.bindInputTexture(M, K + pad, texels0, gl.TEXTURE0, GEMMFloatCalculator.TEXTURE_UNIFORM_NAME_0);\n\tthis.bindInputTexture(N, K + pad, texels1, gl.TEXTURE1, GEMMFloatCalculator.TEXTURE_UNIFORM_NAME_1);\n\n\n\t// set the data specific variables in our shader program\n\tthis.bindUniforms(K + pad, alpha);\n\n\t// create our destination texture\n\tdestTexture = this.webgl.createDestinationTexture(M, N);\n\tframeBuffer = this.webgl.bindDestinationTexture(M, N, destTexture);\n\n\n\tif( gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE)\n\t\tthrow new Error(\"Bound framebuffer is not complete.\");\n\n\t// initiate calculation\n\tgl.drawElements(gl.TRIANGLES, /*num items*/6, gl.UNSIGNED_SHORT, 0);\n\n\t// create destination buffer\n\trawbuffer = new ArrayBuffer(M*N*Float32Array.BYTES_PER_ELEMENT);\n\n\t// read the result into our buffer, as bytes\n\tprod = new Uint8Array(rawbuffer);\n\tgl.readPixels(0, 0, N, M, gl.RGBA, gl.UNSIGNED_BYTE, prod);\n\n\t// create and return a view over result bytes as a float array\n\treturn new Float32Array(rawbuffer); // M x N\n};\n\n/* Pack the given matrix data into texel layout for use by texture shader.\n\n   This layout places consecutive elements of the input data into separate\n   channels, padding to a multiple of four (with zeros) where necessary to fill\n   out the final RGBA texel in a column.\n\n   r - row count\n   c - column count\n   data - TypedArray containing matrix data\n   transpose - whether or not to transpose the data when packing\n */\nGEMMFloatCalculator.packData = function(r, c, data, transpose) {\n\n\tvar CHANNELS_PER_TEXEL = 4; // RGBA: four channels, one per color\n\n\tvar k = !transpose ? c : r;\n\n\tvar mod = (k % CHANNELS_PER_TEXEL),\n\t\tpad = mod == 0 ? 0 : CHANNELS_PER_TEXEL - mod;\n\n\tif (mod === 0 && !transpose) {\n\t\t// special case if column count is a multiple of number of channels\n\t\treturn data;\n\t}\n\n\n\t// dimensions\n\tvar i, j, p;\n\n\tvar texelcount = !transpose ? r*(c + pad) : c*(r + pad);\n\n\t// create Float32Array to hold padded texel data\n\tvar texels = new Float32Array(texelcount);\n\n\tfor(i = 0; i < r; i++){\n\n\t\tif(!transpose){\n\t\t\t// copy actual data\n\t\t\tfor(j = 0; j < c; j++){\n\t\t\t\ttexels[i * (c + pad) + j] = data[i * c + j];\n\t\t\t}\n\n\t\t\t// pad last texel in this row with zeros\n\t\t\tfor(p = 0; p < pad; p++){\n\t\t\t\ttexels[i * (c + pad) + j + p] = 0.0;\n\t\t\t}\n\t\t} else {\n\t\t\t// copy actual data, transposed\n\t\t\tfor(j = 0; j < c; j++){\n\t\t\t\ttexels[j * (r + pad) + i] = data[i * c + j];\n\t\t\t}\n\n\t\t\t// pad last texel in this row with zeros\n\t\t\tfor(p = 0; p < pad; p++){\n\t\t\t\ttexels[j * (r + pad) + i + p] = 0.0;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn texels;\n};\n\n/* Create a texture from the given texel data and bind it to our shader program.\n\n\th - number of rows in input matrix\n\tw - number of cols in input matrix\n\ttexels - packed data\n\ttextureUnit - the texture unit to bind to (gl.TEXTURE0, gl.TEXTURE1, etc)\n\tname - the uniform name to associate with (must match shader program)\n\n\tmust compile program (with createProgram) first\n*/\nGEMMFloatCalculator.prototype.bindInputTexture = function(h, w, texels, textureUnit, name){\n\tvar gl = this.webgl.context,\n\t\tprogram = this.program;\n\n\n\n\t// create the texture from our floats\n\tvar texture = gl.createTexture();\n\tgl.activeTexture(textureUnit); // gl.TEXTURE0, gl.TEXTURE1, etc\n\tgl.bindTexture(\t  gl.TEXTURE_2D, texture);\n\tgl.texImage2D(\t  gl.TEXTURE_2D, /*level*/0, gl.RGBA, w / 4, h, 0,\n\t\t\t\t\t  gl.RGBA, gl.FLOAT, texels);\n\n\t// clamp to edge to support non-power of two textures\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t// don't interpolate when getting data from texture\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n\tvar sampler = gl.getUniformLocation(program, name);\n\tgl.uniform1i(sampler, textureUnit - gl.TEXTURE0);\n\n\treturn texture;\n};\n\n/* Set up inputs for the texture shader\n\n\tK - size of shared dimension for multiplied matrices\n */\nGEMMFloatCalculator.prototype.bindUniforms = function(K, alpha) {\n\tvar gl = this.webgl.context;\n\n\t// get var locations\n\tvar K_gl\t= gl.getUniformLocation(this.program, GEMMFloatCalculator.SHARED_LENGTH_UNIFORM_NAME),\n\t\talpha_gl = gl.getUniformLocation(this.program, GEMMFloatCalculator.ALPHA_UNIFORM_NAME);\n\n\t// bind length of shared dimension\n\tgl.uniform1i(K_gl, K);\n\tgl.uniform1f(alpha_gl, alpha);\n\n};\n","var async = require('async'),\n\tloader = require('floader'); // browserify aware file loader (xhr in browser)\n\n/* Collection of helper methods for testing numerical computation\n */\ntest = {};\n\n/* Check all entries in two TypedArrays of identical length for approximate\n\tequality.\n\tIf the following equation is element-wise true, returns true\n\n\tabsolute(a - b) <= (atol + rtol * absolute(b))\n\n\tfrom numpy.allclose\n */\ntest.allclose = function(a, b, RTOL, ATOL){\n\tRTOL= RTOL || 1e-05;  // for 32 bit precision: 1e-06\n\tATOL= ATOL || 1e-12;\n\n\tif(a.length != b.length){\n\t\tconsole.log(\"lengths not equal: \" + a.length + \", \" + b.length);\n\t\treturn {\"result\" : false, \"index\": null};\n\t}\n\n\tvar result;\n\tfor(var i = 0; i < a.length; i++){\n\n\t\tresult = Math.abs(a[i] - b[i]) <= ATOL + RTOL * Math.abs(b[i]);\n\n\t\tif(!result) {\n\t\t\treturn {\"result\": false, \"index\": i};\n\t\t}\n\t}\n\n\treturn {\"result\": true, \"index\": i};\n};\n\ntest.randomArray = function(N, M){\n\n\tvar data = [];\n\n\tfor(var i = 0; i < N; i++){\n\t\tvar row = [];\n\t\tfor(var j = 0; j < M; j++){\n\t\t\trow[j] = Math.random() / Math.sqrt(N);\n\t\t}\n\t\tdata.push(row);\n\t}\n\n\treturn data;\n};\n\nvar matrixFiles = ['a.json', 'b.json', 'c.json'];\n\n/* Load test matrices from JSON data, works in a browser (with XHR)\n\tassumes three files 'a.json', 'b.json' and 'c.json' in nested Array format.\n\n callback = function(err, a, b, c)\n */\ntest.load = function(testDirectory, callback){\n\n\tvar a, b, c; // javascript arrays\n\n\t// array of paths to matrix data files for current test\n\tvar testFiles = matrixFiles.map(function(item){ return testDirectory + item;});\n\n\t//console.log(testFiles);\n\tasync.map(testFiles, loader.load,\n\t\tfunction(err, results){\n\n\t\t\tif(err) return callback(err);\n\n\t\t\t// results contains three strings.\n\t\t\t// each string contains the contents of a file\n\t\t\t// files contain JSON describing a matrix (2D array)\n\t\t\ta = JSON.parse(results[0]);\n\t\t\tb = JSON.parse(results[1]);\n\t\t\tc = JSON.parse(results[2]);\n\n\t\t\tcallback(err, a, b, c);\n\t\t}\n\t);\n};\n\nmodule.exports = test;\n","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (!callback) {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has inexistant dependency');\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback(null);\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    while(workers < q.concurrency && q.tasks.length){\n                        var tasks = q.payload ?\n                            q.tasks.splice(0, q.payload) :\n                            q.tasks.splice(0, q.tasks.length);\n\n                        var data = _map(tasks, function (task) {\n                            return task.data;\n                        });\n\n                        if (q.tasks.length === 0) {\n                            q.empty();\n                        }\n                        workers += 1;\n                        workersList.push(tasks[0]);\n                        var cb = only_once(_next(q, tasks));\n                        worker(data, cb);\n                    }\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","exports.load = function(url, callback) {\n\tvar xhr = new XMLHttpRequest();\n\n\txhr.onreadystatechange = function() {\n\t\tif (xhr.readyState !== 4) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (xhr.status >= 200 && xhr.status < 300) {\n\t\t\tcallback(null, xhr.responseText);\n\t\t} else {\n\t\t\tvar err = new Error(\"failed to request file '\" + url + \"'\");\n\t\t\t// follow Node.js error signature\n\t\t\terr.errno = 34;\n\t\t\tcallback(err);\n\t\t}\n\t};\n\n\ttry {\n\t\txhr.open('GET', url, true);\n\t\txhr.send(null);\n\t} catch (err) {\n\t\tcallback(err);\n\t}\n};","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"]}